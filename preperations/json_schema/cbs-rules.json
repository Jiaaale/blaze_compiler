{
    "rules": {
        // By default, make all data private unless specified otherwise.
        ".read": false,
        ".write": false,
        "moderators": {
            ".read": "(auth != null)"
        },
        "room-metadata": {
            ".read": "true",
            "$roomId": {
                // Append-only by anyone, and admins can add official rooms, and edit or remove rooms as well.
                ".write": "(auth != null) && (!data.exists() || root.child('moderators').hasChild(auth.id) || data.child('createdByUserId').val() === auth.id)",
                ".validate": "newData.hasChildren(['name','type','createdByUserId','createdAt','numUsers'])",
                "id": {
                    ".validate": "(newData.val() === $roomId)"
                },
                "createdByUserId": {
                    ".validate": "(auth.id === newData.val())"
                },
                "numUsers": {
                    ".validate": "(newData.isNumber())"
                },
                "type": {
                    ".validate": "('public' === newData.val()) || ('official' === newData.val() && (root.child('moderators').hasChild(auth.id)))"
                }
            }
        },
        "room-metadata-private": {
            "$roomId": {
                // Append-only by anyone, and admins can add official rooms, and edit or remove rooms as well.
                ".write": "(auth != null) && (!data.exists() || root.child('moderators').hasChild(auth.id) || data.child('createdByUserId').val() === auth.id)",
                ".validate": "newData.hasChildren(['name','type','createdByUserId','createdAt','numUsers'])",
                ".read": true,
                "id": {
                    ".validate": "(newData.val() === $roomId)"
                },
                "createdByUserId": {
                    ".validate": "(auth.id === newData.val())"
                },
                "numUsers": {
                    ".validate": "(newData.isNumber())"
                },
                "type": {
                    ".validate": "('private' === newData.val())"
                },
                // A list of users that may read messages from this room.
                "authorizedUsers": {
                    ".write": "(auth != null) && (!data.exists() || root.child('moderators').hasChild(auth.id) || data.hasChild(auth.id))"
                }
            }
        },
        "room-users": {
            "$roomId": {
                ".read": "(auth != null)",
                "$userId": {
                    // A list of users by room, public.
                    ".write": "(auth != null) && ($userId === auth.id || root.child('moderators').hasChild(auth.id))",
                    "$sessionId": {
                        ".validate": "(!newData.exists() || newData.hasChildren(['id','name']))"
                    }
                }
            }
        },
        "user-names": {
            // A mapping of lowercase usernames to user ids.
            ".read": "(auth != null)",
            "$username": {
                ".write": "(auth != null) && (!data.exists() || data.child('id').val() === auth.id)",
                "id": {
                    ".validate": "(newData.val() === auth.id)"
                },
                "name": {
                    ".validate": "(newData.isString())"
                }
            }
        },
        "user-names-online": {
            // A mapping of active, online lowercase usernames to sessions and user ids.
            ".read": "(auth != null)",
            "$username": {
                "$sessionId": {
                    ".write": "(auth != null)",
                    "id": {
                        ".validate": "(!newData.exists() || newData.val() === auth.id)"
                    },
                    "name": {
                        ".validate": "(!newData.exists() || newData.isString())"
                    }
                }
            }
        },
        "room-messages": {
            "$roomId": {
                // A list of messages by room, readable by anyone.
                ".read": "(auth != null)",
                "$msgId": {
                    // Allow anyone to append to this list and allow admins to edit or remove.
                    ".write": "(auth != null) && (data.val() === null || root.child('moderators').hasChild(auth.id)) && (!root.child('suspensions').hasChild(auth.id) || root.child('suspensions').child(auth.id).val() < now)",
                    ".validate": "(newData.hasChildren(['userId','name','message','timestamp']))",
                    "name": {
                        ".validate": "(newData.val() === root.child('users').child(auth.id).child('name').val())"
                    }
                }
            }
        },
        "users": {
            // A list of users and their associated metadata, which can be updated by the single user or a moderator.
            "$userId": {
                ".write": "(auth != null) && (auth.id === $userId || (root.child('moderators').hasChild(auth.id)))",
                ".read": "(auth != null) && (auth.id === $userId || (root.child('moderators').hasChild(auth.id)))",
                ".validate": "($userId === newData.child('id').val())",
                "invites": {
                    // A list of chat invitations from other users, append-only by anyone.
                    "$inviteId": {
                        // Allow the user who created the invitation to read the status of the invitation.
                        ".read": "(auth != null) && (auth.id === data.child('fromUserId').val())",
                        ".write": "(auth != null) && (!data.exists() || $userId === auth.id || data.child('fromUserId').val() === auth.id) && (!root.child('suspensions').hasChild(auth.id) || root.child('suspensions').child(auth.id).val() < now)",
                        ".validate": "newData.hasChildren(['fromUserId','fromUserName','toRoomId','toRoomName']) && (newData.child('id').val() === $inviteId)"
                    }
                },
                "notifications": {
                    // A list of notifications, which can only be appended to by moderators.
                    "$notificationId": {
                        ".write": "(auth != null) && (data.val() === null) && (root.child('moderators').hasChild(auth.id))",
                        ".validate": "newData.hasChildren(['fromUserId','timestamp','notificationType'])",
                        "fromUserId": {
                            ".validate": "newData.val() === auth.id"
                        }
                    }
                }
            }
        },
        "suspensions": {
            ".write": "(auth != null) && (root.child('moderators').hasChild(auth.id))",
            ".read": "(auth != null) && (root.child('moderators').hasChild(auth.id))"
        },
        "flags": {
            // A list of flagged messages, append-only by anyone.
            "$flagId": {
                ".write": "(auth != null) && (!newData.exists() || newData.child('reportedByUserId').val() === auth.id)",
                ".read": "(auth != null) && (root.child('moderators').hasChild(auth.id))",
                ".validate": "(!newData.exists() || newData.hasChildren(['reportedByUserId','userId','roomId','messageId']))"
            }
        }
    }
}

